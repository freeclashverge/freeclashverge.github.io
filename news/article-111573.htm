<!doctype html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://freeclashverge.github.io/news/article-111573.htm" />
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具</title>
        <meta name="description" content="0. 前言 面试官：「你写个 Promise 吧。」 我：「对不起，打扰了，再见！」 现在前端越来越卷，不会手写 Promise 都不好意思面试了（手动狗头.jpg）。虽然没多少人会在业务中用自己实现" />
        <link rel="icon" href="/assets/website/img/freeclashverge/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="FreeClashVerge免费节点官网">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://freeclashverge.github.io/news/article-111573.htm" />
    <meta property="og:site_name" content="FreeClashVerge免费节点官网" />
    <meta property="og:title" content="按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具" />
    <meta property="og:image" content="https://freeclashverge.github.io/uploads/20240813-1/9af021a1368565bad3accbd18dc8d6d2.webp" />
        <meta property="og:release_date" content="2025-05-04T09:28:53" />
    <meta property="og:updated_time" content="2025-05-04T09:28:53" />
        <meta property="og:description" content="0. 前言 面试官：「你写个 Promise 吧。」 我：「对不起，打扰了，再见！」 现在前端越来越卷，不会手写 Promise 都不好意思面试了（手动狗头.jpg）。虽然没多少人会在业务中用自己实现" />
        
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/assets/website/css/freeclashverge/bootstrap.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/freeclashverge/linericon/style.css">
    <link rel="stylesheet" href="/assets/website/css/freeclashverge/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/freeclashverge/owl-carousel/owl.carousel.min.css">
    <link rel="stylesheet" href="/assets/website/css/freeclashverge/magnific-popup.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/freeclashverge/nice-select/css/nice-select.css">
    <!-- main css -->
    <link rel="stylesheet" href="/assets/website/css/freeclashverge/style.css">
    <link rel="stylesheet" href="/assets/website/css/G.css" />
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BZVJP9BVQB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BZVJP9BVQB');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--================ Start Header Area =================-->
    <header class="header_area">
        <div class="main_menu">
            <nav class="navbar navbar-expand-lg navbar-light">
                <div class="container">
                    <!-- Brand and toggle get grouped for better mobile display -->
                    <a class="navbar-brand logo_h" href="/">
                                                <span>Free Clash Verge</span>
                                            </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse offset" id="navbarSupportedContent">
                        <ul class="nav navbar-nav menu_nav justify-content-end">
                                                        <li class="nav-item"><a class="nav-link" href="/">首页</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/free-nodes/">免费节点</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/paid-subscribe/">推荐机场</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/client.htm">客户端</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/news/">新闻资讯</a></li>
                                                    </ul>
                    </div>
                </div>
            </nav>
        </div>
    </header>
    <!--================ End Header Area =================-->
    <!--================ Start Banner Area =================-->
    <section class="banner_area">
        <div class="banner_inner d-flex align-items-center">
            <div class="container">
                <div class="banner_content text-center">
                    <h1>按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具</h1>
                    <div class="page_link">
                        <a href="/">首页</a>
                        <a href="/news/">新闻资讯</a>
                        <span>正文</span>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <!--================ End Banner Area =================-->
    <!--================ Start About Us Area =================-->
    <section class="about_area section_gap">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                <div class="xcblog-blog-detail xcblog-blog-detail-defined">
                      				  				  				<h2 id="0-前言">0. 前言</h2> <p>面试官：「你写个 Promise 吧。」</p> <p>我：「对不起，打扰了，再见！」</p> <p>现在前端越来越卷，不会手写 <code>Promise</code> 都不好意思面试了（手动狗头.jpg）。虽然没多少人会在业务中用自己实现的 <code>Promise</code>，但是，实现 <code>Promise</code> 的过程会让你对 <code>Promise</code> 更加了解，出了问题也可以更好地排查。</p> <p>如果你还不熟悉 Promise，建议先看一下 MDN 文档。</p> <p>在实现 Promise 之前，我建议你先看一遍 Promises/A+ 规范（中文翻译：Promise A+ 规范），<strong>本文中不会再次介绍相关的概念</strong>。推荐大家优先阅读原版英文，只需高中水平的英语知识就够了，遇到不懂的再看译文。</p> <p>另外，本文将使用 ES6 中的 Class 来实现 <code>Promise</code>。为了方便大家跟 Promise/A+ 规范对照着看，下文的顺序将按照规范的顺序来行文。</p> <p>在正式开始之前，我们新建一个项目，名称随意，按照以下步骤进行初始：</p> <ul> <li>打开 CMD 或 VS Code，运行 <code>npm init</code>，初始化项目</li> <li>新建 <code>PromiseImpl.js</code> 文件，后面所有的代码实现都写在这个文件里</li> </ul> <p><strong>完整代码地址：</strong>ashengtan/promise-aplus-implementing</p> <h2 id="1-术语">1. 术语</h2> <p>这部分大家直接看规范就好，也没什么好解释的。注意其中对于 <code>value</code> 的描述，<code>value</code> 可以是一个 <code>thenable</code>（有 <code>then</code> 方法的对象或函数） 或者 <code>Promise</code>，这点会在后面的实现中体现出来。</p> <h2 id="2-要求">2. 要求</h2> <h3 id="21-promise-的状态">2.1 Promise 的状态</h3> <p>一个 <code>Promise</code> 有三种状态：</p> <ul> <li> <code>pending</code>：初始状态</li> <li> <code>fulfilled</code>：成功执行</li> <li> <code>rejected</code>：拒绝执行</li> </ul> <p>一个 <code>Promise</code> 一旦从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，就无法变成其他状态。当 <code>fulfilled</code> 时，需要给出一个不可变的值；同样，当 <code>rejected</code> 时，需要给出一个不可变的原因。</p> <p>根据以上信息，我们定义 3 个常量，用来表示 <code>Promise</code> 的状态：</p> <pre><code class="language-javascript">const STATUS_PENDING = 'pending' const STATUS_FULFILLED = 'fulfilled' const STATUS_REJECTED = 'rejected' </code></pre> <p>接着，我们先把 <code>Promise</code> 的基础框架先定义出来，这里我使用 ES6 的 Class 来定义：</p> <pre><code class="language-javascript">class PromiseImpl {   constructor() {}    then(onFulfilled, onRejected) {} } </code></pre> <p>这里我们先回想一下 <code>Promise</code> 的基本用法：</p> <pre><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {   // ...do something   resolve(value) // or reject(error) })  // 多次调用 const p1 = promise.then() const p2 = promise.then() const p3 = promise.then() </code></pre> <p>好了，继续完善 <code>PromiseImpl</code>，先完善一下构造方法：</p> <pre><code class="language-javascript">class PromiseImpl {   constructor() {     // `Promise` 当前的状态，初始化时为 `pending`     this.status = STATUS_PENDING     // fulfilled 时的值     this.value = null     // rejected 时的原因     this.reason = null   } } </code></pre> <p>另外，我们还要定义两个方法，用于 <code>fulfilled</code> 和 <code>rejected</code> 时回调：</p> <pre><code class="language-javascript">class PromiseImpl {   constructor() {     // ...其他代码      // 2.1.2 When `fulfilled`, a `promise`:     //  2.1.2.1 must not transition to any other state.     //  2.1.2.2 must have a value, which must not change.     const _resolve = value =&gt; {       // 如果 `value` 是 `Promise`（即嵌套 `Promise`），       // 则需要等待该 `Promise` 执行完成       if (value instanceof PromiseImpl) {         return value.then(           value =&gt; _resolve(value),           reason =&gt; _reject(reason)         )       }              if (this.status === STATUS_PENDING) {         this.status = STATUS_FULFILLED         this.value = value       }     }      // 2.1.3 When `rejected`, a `promise`:     //  2.1.3.1 must not transition to any other state.     //  2.1.3.2 must have a reason, which must not change.     const _reject = reason =&gt; {       if (this.status === STATUS_PENDING) {         this.status = STATUS_REJECTED         this.reason = reason       }     }   } } </code></pre> <p><strong>注意</strong>，在 <code>_resolve()</code> 中，如果 <code>value</code> 是 <code>Promise</code> 的话（即嵌套 <code>Promise</code>），则需要等待该 <code>Promise</code> 执行完成。这点很重要，因为后面的其他 API 如 <code>Promise.resolve</code>、<code>Promise.all</code>、<code>Promise.allSettled</code> 等均需要等待嵌套 <code>Promise</code> 执行完成才会返回结果。</p> <p>最后，别忘了在 <code>new Promise()</code> 时，我们需要将 <code>resolve</code> 和 <code>reject</code> 传给调用者：</p> <pre><code class="language-javascript">class PromiseImpl {   constructor(executor) {     // ...其他代码      try {       executor(_resolve, _reject)     } catch (e) {       _reject(e)     }   } } </code></pre> <p>使用 <code>trycatch</code> 将 <code>executor</code> 包裹起来，因为这部分是调用者的代码，我们无法保证调用者的代码不会出错。</p> <h3 id="22-then-方法">2.2 Then 方法</h3> <p>一个 <code>Promise</code> 必须提供一个 <code>then</code> 方法，其接受两个参数：</p> <pre><code class="language-javascript">promise.then(onFulfilled, onRejected) </code></pre> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {} } </code></pre> <h4 id="221-onfulfilled-和-onrejected">2.2.1 <code>onFulfilled</code> 和 <code>onRejected</code><br /> </h4> <p>从规范 2.2.1 中我们可以得知以下信息：</p> <ul> <li> <code>onFulfilled</code> 和 <code>onRejected</code> 是可选参数</li> <li>如果 <code>onFulfilled</code> 和 <code>onRejected</code> 不是函数，则必须被忽略</li> </ul> <p>因此，我们可以这样实现：</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // 2.2.1 Both `onFulfilled` and `onRejected` are optional arguments:     //   2.2.1.1 If `onFulfilled` is not a function, it must be ignored     //   2.2.1.2 If `onRejected` is not a function, it must be ignored     onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : () =&gt; {}     onRejected = typeof onRejected === 'function' ? onRejected : () =&gt; {}   } } </code></pre> <h4 id="222-onfulfilled-特性">2.2.2 <code>onFulfilled</code> 特性</h4> <p>从规范 2.2.2 中我们可以得知以下信息：</p> <ul> <li>如果 <code>onFulfilled</code> 是一个函数，则必须在 <code>fulfilled</code> 后调用，第一个参数为 <code>promise</code> 的值</li> <li>只能调用一次</li> </ul> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码          // 2.2.2 If `onFulfilled` is a function:     //   2.2.2.1 it must be called after `promise` is fulfilled,     // with promise’s value as its first argument.     //   2.2.2.2 it must not be called before `promise` is fulfilled.     //   2.2.2.3 it must not be called more than once.     if (this.status === STATUS_FULFILLED) {       onFulfilled(this.value)     }   } } </code></pre> <h4 id="223-onrejected-特性">2.2.3 <code>onRejected</code> 特性</h4> <p>与 <code>onFulfilled</code> 同理，只不过是在 <code>rejected</code> 时调用，第一个参数为 <code>promise</code> 失败的原因</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码      // 2.2.3 If onRejected is a function:     //   2.2.3.1 it must be called after promise is rejected,     // with promise’s reason as its first argument.     //   2.2.3.2 it must not be called before promise is rejected.     //   2.2.3.3 it must not be called more than once.     if (this.status === STATUS_REJECTED) {       onRejected(this.reason)     }   } } </code></pre> <h4 id="224-异步执行">2.2.4 异步执行</h4> <p>在日常开发中，我们经常使用 <code>Promise</code> 来做一些异步操作，规范 2.2.4 就是规定异步执行的问题，具体的可以结合规范里的注释阅读，重点是确保 <code>onFulfilled</code> 和 <code>onRejected</code> 要异步执行。</p> <p>需要指出的是，规范里并没有规定 <code>Promise</code> 一定要用 <code>micro-task</code> 机制来实现，因此你使用 <code>macro-task</code> 机制来实现也是可以的。当然，现在浏览器用的是 <code>micro-task</code> 来实现。这里为了方便，我们使用 <code>setTimeout</code>（属于 <code>macro-task</code>）来实现。</p> <p>因此，我们需要稍微改造下上面的代码：</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码 	     // fulfilled     if (this.status === STATUS_FULFILLED) {       setTimeout(() =&gt; {         onFulfilled(this.value)       }, 0)     }      // rejected     if (this.status === STATUS_REJECTED) {       setTimeout(() =&gt; {         onRejected(this.reason)       }, 0)     }   } } </code></pre> <h4 id="225-onfulfilled-和-onrejected-必须作为函数被调用">2.2.5 <code>onFulfilled</code> 和 <code>onRejected</code> 必须作为函数被调用</h4> <p>这个已经在上面实现过了。</p> <h4 id="226-then-可被多次调用">2.2.6 <code>then</code> 可被多次调用</h4> <p>举个例子：</p> <pre><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {   // ...do something   resolve(value) // or reject(error) })  promise.then() promise.then() promise.catch() </code></pre> <p>因此，必须确保当 <code>Promise</code> <code>fulfilled</code> 或 <code>rejected</code> 时，<code>onFulfilled</code> 或 <code>onRejected</code> 按照其注册的顺序逐一回调。还记得最开始我们定义的 <code>resolve</code> 和 <code>reject</code> 吗？这里我们需要改造下，保证所有的回调都被执行到：</p> <pre><code class="language-javascript">const invokeArrayFns = (fns, arg) =&gt; {   for (let i = 0; i &lt; fns.length; i++) {     fns[i](arg)   } }  class PromiseImpl {   constructor(executor) {     // ...其他代码      // 用于存放 `fulfilled` 时的回调，一个 `Promise` 对象可以注册多个 `fulfilled` 回调函数     this.onFulfilledCbs = []     // 用于存放 `rejected` 时的回调，一个 `Promise` 对象可以注册多个 `rejected` 回调函数     this.onRejectedCbs = []      const resolve = value =&gt; {       if (this.status === STATUS_PENDING) {         this.status = STATUS_FULFILLED         this.value = value         // 2.2.6.1 If/when `promise` is fulfilled,          // all respective `onFulfilled` callbacks must execute          // in the order of their originating calls to `then`.         invokeArrayFns(this.onFulfilledCbs, value)       }     }      const reject = reason =&gt; {       if (this.status === STATUS_PENDING) {         this.status = STATUS_REJECTED         this.reason = reason         // 2.2.6.2 If/when `promise` is rejected,          // all respective `onRejected` callbacks must execute          // in the order of their originating calls to `then`.         invokeArrayFns(this.onRejectedCbs, reason)       }     }   } } </code></pre> <p>看到这里你可能会有疑问，什么时候往 <code>onFulfilledCbs</code> 和 <code>onRejectedCbs</code> 里存放对应的回调，答案是在调用 <code>then</code> 时：</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码      // pending     if (this.status === STATUS_PENDING) {       this.onFulfilledCbs.push(() =&gt; {         setTimeout(() =&gt; {           onFulfilled(this.value)         }, 0)       })        this.onRejectedCbs.push(() =&gt; {         setTimeout(() =&gt; {           onRejected(this.reason)         }, 0)       })     }   } } </code></pre> <p>此时 <code>Promise</code> 处于 <code>pending</code> 状态，无法确定其最后是 <code>fulfilled</code> 还是 <code>rejected</code>，因此需要将回调函数存放起来，待状态确定后再执行相应的回调函数。</p> <p>注：<code>invokeArrayFns</code> 来源于 Vue.js 3 中的源码。</p> <h4 id="227-then-必须返回-promise">2.2.7 <code>then</code> 必须返回 <code>Promise</code><br /> </h4> <pre><code class="language-javascript">promise2 = promise1.then(onFulfilled, onRejected) </code></pre> <p>那么，在我们上面的代码中，<code>then</code> 怎么才能返回 <code>Promise</code> 呢？很简单：</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     let promise2 = new PromiseImpl((resolve, reject) =&gt; {       if (this.status === STATUS_FULFILLED) {         // ...相关代码       }        if (this.status === STATUS_REJECTED) {         // ...相关代码       }        if (this.status === STATUS_PENDING) {         // ...相关代码       }     })      return promise2   } } </code></pre> <p>因为调用 <code>then</code> 之后返回一个新的 <code>Promise</code> 对象，使得我们也可以进行链式调用：</p> <pre><code class="language-javascript">Promise.resolve(42).then().then()... </code></pre> <p>2.2.7.1 ~ 2.2.7.4 这四点比较重要，我们下面分别来看看。</p> <p><strong>2.2.7.1</strong> 如果 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值 <code>x</code>，则运行 <code>Promise</code> 解决过程，<code>[[Resolve]](promise2, x)</code>。</p> <p>解释：其实所谓运行 <code>Promise</code> 解决过程就是执行某个操作，我们把这个操作抽取成一个方法，并命名为：<code>promiseResolutionProcedure(promise, x, resolve, reject)</code>。为了方便，我们把 <code>resolve</code> 和 <code>reject</code> 一并透传进去。</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码          let promise2 = new PromiseImpl((resolve, reject) =&gt; {       if (this.status === STATUS_FULFILLED) {         setTimeout(() =&gt; {           // 2.2.7.1           let x = onFulfilled(this.value)           promiseResolutionProcedure(promise2, x, resolve, reject)         }, 0)       }        if (this.status === STATUS_REJECTED) {         setTimeout(() =&gt; {           // 2.2.7.1           let x = onRejected(this.reason)           promiseResolutionProcedure(promise2, x, resolve, reject)         }, 0)       }        if (this.status === STATUS_PENDING) {         this.onFulfilledCbs.push(() =&gt; {           setTimeout(() =&gt; {             // 2.2.7.1              let x = onFulfilled(this.value)             promiseResolutionProcedure(promise2, x, resolve, reject)           }, 0)         })          this.onRejectedCbs.push(() =&gt; {           setTimeout(() =&gt; {             // 2.2.7.1             let x = onRejected(this.reason)             promiseResolutionProcedure(promise2, x, resolve, reject)           }, 0)         })       }     })      return promise2   } } </code></pre> <p><strong>2.2.7.2</strong> 如果 <code>onFulfilled</code> 或 <code>onRejected</code> 抛出一个异常 <code>e</code>，则 <code>promise2</code> 必须 <code>rejected</code>，并返回原因 <code>e</code>。</p> <p>解释：实现上面体现在执行 <code>onFulfilled</code> 或 <code>onRejected</code> 时使用 <code>trycatch</code> 包括起来，并在 <code>catch</code> 时调用 <code>reject(e)</code>。</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     // ...其他代码          let promise2 = new PromiseImpl((resolve, reject) =&gt; {       if (this.status === STATUS_FULFILLED) {         setTimeout(() =&gt; {           try {             // 2.2.7.1             let x = onFulfilled(this.value)             promiseResolutionProcedure(promise2, x, resolve, reject)           } catch (e) {             // 2.2.7.2             reject(e)           }         }, 0)       }        if (this.status === STATUS_REJECTED) {         setTimeout(() =&gt; {           try {             // 2.2.7.1             let x = onRejected(this.reason)             promiseResolutionProcedure(promise2, x, resolve, reject)           } catch (e) {             // 2.2.7.2             reject(e)           }         }, 0)       }        if (this.status === STATUS_PENDING) {         this.onFulfilledCbs.push(() =&gt; {           setTimeout(() =&gt; {             try {               // 2.2.7.1               let x = onFulfilled(this.value)               promiseResolutionProcedure(promise2, x, resolve, reject)             } catch (e) {               // 2.2.7.2               reject(e)             }           }, 0)         })          this.onRejectedCbs.push(() =&gt; {           setTimeout(() =&gt; {             try {               // 2.2.7.1               let x = onRejected(this.reason)               promiseResolutionProcedure(promise2, x, resolve, reject)             } catch (e) {               // 2.2.7.2               reject(e)             }           }, 0)         })       }     })      // 2.2.7 `then` must return a promise     return promise2   } } </code></pre> <p><strong>2.2.7.3</strong> 如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 已经 <code>fulfilled</code>，则 <code>promise2</code> 必须 <code>fulfilled</code> 且返回与 <code>promise1</code> 相同的值。</p> <p>解释：值的透传，例如：</p> <pre><code class="language-javascript">Promise.resolve(42).then().then(value =&gt; console.log(value)) // 42 </code></pre> <p>在第一个 <code>then</code> 时，我们忽略了 <code>onFulfilled</code>，那么在链式调用的时候，需要把值透传给后面的 <code>then</code>：</p> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value      // ...其他代码   } } </code></pre> <p><strong>2.2.7.4</strong> 如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 已经 <code>rejected</code>，则 <code>promise2</code> 必须 <code>rejected</code> 且返回与 <code>promise1</code> 相同的原因。</p> <p>解释：同理，原因也要透传：</p> <pre><code class="language-javascript">Promise.reject('reason').catch().catch(reason =&gt; console.log(reason)) // 'reason' </code></pre> <pre><code class="language-javascript">class PromiseImpl {   then(onFulfilled, onRejected) {     onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason }      // ...其他代码   } } </code></pre> <h3 id="23-promise-解决过程">2.3 Promise 解决过程</h3> <p><code>Promise</code> 解决过程是一个抽象的操作，输入一个 <code>promise</code> 和一个值，这里我们将其命名为 <code>promiseResolutionProcedure(promise, x, resolve, reject)</code>，并在调用时传入 <code>resolve</code> 和 <code>reject</code> 两个方法， 分别用于在 <code>fulfilled</code> 和 <code>rejected</code> 时调用。</p> <h4 id="231-如果-promise-和-x-为同一个对象">2.3.1 如果 <code>promise</code> 和 <code>x</code> 为同一个对象</h4> <p>如果 <code>promise</code> 和 <code>x</code> 为同一个对象，拒绝该 <code>promise</code>，原因为 <code>TypeError</code>。</p> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // 2.3.1 If `promise` and `x` refer to the same object,   // reject `promise` with a `TypeError` as the reason   if (promise === x) {     return reject(new TypeError('`promise` and `x` refer to the same object, see: https://promisesaplus.com/#point-48'))   }    // ...其他代码 } </code></pre> <h4 id="232-如果-x-是一个-promise-对象">2.3.2 如果 <code>x</code> 是一个 Promise 对象</h4> <p>如果 <code>x</code> 是一个 <code>Promise</code> 对象，则需要递归执行：</p> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码    // 2.3.2 If `x` is a promise, adopt its state:   //   2.3.2.1 If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.   //   2.3.2.2 If/when `x` is fulfilled, fulfill `promise` with the same value.   //   2.3.2.3 If/when `x` is rejected, reject `promise` with the same reason.   if (x instanceof PromiseImpl) {     return x.then(       value =&gt; promiseResolutionProcedure(promise, value, resolve, reject),       reason =&gt; reject(reason)     )   } } </code></pre> <h4 id="233-如果-x-是一个对象或函数">2.3.3 如果 <code>x</code> 是一个对象或函数</h4> <p>如果 <code>x</code> 是一个对象或函数：</p> <p><strong>2.3.3.1</strong> 将 <code>x.then</code> 赋值给 <code>x</code></p> <p>解释：这样做有两个目的：</p> <ul> <li>避免对 <code>x.then</code> 的多次访问（这也是日常开发中的一个小技巧，当要多次访问一个对象的同一属性时，通常我们会使用一个变量将该属性存储起来，避免多次进行原型链查找）</li> <li>执行过程中 <code>x.then</code> 的值可能被改变</li> </ul> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码    // 2.3.3 Otherwise, if x is an object or function   if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {          // 2.3.3.1 Let `then` be `x.then`     let then = x.then   } } </code></pre> <p><strong>2.3.3.2</strong> 如果在对 <code>x.then</code> 取值时抛出异常 <code>e</code>，则拒绝该 <code>promise</code>，原因为 <code>e</code></p> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码    if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {          try {       // 2.3.3.1 Let `then` be `x.then`     } catch (e) {       // 2.3.3.2 If retrieving the property `x.then` results in a thrown exception `e`,       // reject `promise` with `e` as the reason.       reject(e)     }   } } </code></pre> <p><strong>2.3.3.3</strong> 如果 <code>then</code> 是函数</p> <p>如果 <code>then</code> 是函数，则将 <code>x</code> 作为 <code>then</code> 的作用域，并调用 <code>then</code>，同时传入两个回调函数，第一个名为 <code>resolvePromise</code>，第二个名为 <code>rejectPromise</code>。</p> <p>解释：意思就是在调用 <code>then</code> 的时候要指定其 <code>this</code> 值为 <code>x</code>，同时需要传入两个回调函数。这时候用 <code>call()</code> 来实现是最好不过了：</p> <pre><code class="language-javascript">then.call(x, resolvePromise, rejectPromise) </code></pre> <p><strong>2.3.3.3.1 ~ 2.3.3.3.4</strong> 总结起来的意思如下：</p> <ul> <li> <p><strong>2.3.3.3.1</strong> 如果 <code>resolvePromise</code> 被调用，则递归调用 <code>promiseResolutionProcedure</code>，值为 <code>y</code>。因为 <code>Promise</code> 中可以嵌套 <code>Promise</code>：</p> <pre><code class="language-javascript">then.call(   x,   y =&gt; promiseResolutionProcedure(promise, y, resolve, reject),   rejectPromise ) </code></pre> </li> <li> <p><strong>2.3.3.3.2</strong> 如果 <code>rejectPromise</code> 被调用，参数为 <code>r</code>，则拒绝执行 <code>Promise</code>，原因为 <code>r</code>：</p> <pre><code class="language-javascript">then.call(   x,   y =&gt; promiseResolutionProcedure(promise, y, resolve, reject), // resolvePromise   r =&gt; reject(r) // rejectPromise ) </code></pre> </li> <li> <p><strong>2.3.3.3.3</strong> 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则只执行首次调用</p> <p>解释：这里我们可以通过设置一个标志位来解决，然后分别在 <code>resolvePromise</code> 和 <code>rejectPromise</code> 这两个回调函数内做判断：</p> <pre><code class="language-javascript">// 初始化时设置为 false let called = false  if (called) {     return }  // `resolvePromise` 和 `rejectPromise` 被调用时设置为 true called = true </code></pre> </li> <li> <p><strong>2.3.3.3.4</strong> 调用 <code>then</code> 抛出异常 <code>e</code> 时，如果这时 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略；否则拒绝该 <code>Promise</code>，原因为 <code>e</code></p> </li> </ul> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码      let called = false    if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {     try {       let then = x.then        if (typeof then === 'function') {         // 2.3.3.3 If `then` is a function, call it with `x` as `this`,         // first argument `resolvePromise`, and second argument `rejectPromise`         then.call(           // call it with `x` as `this`           x,            // `resolvePromise`           // 2.3.3.3.1 If/when `resolvePromise` is called with a value `y`,           // run `[[Resolve]](promise, y)`.           y =&gt; {             // 2.3.3.3.3 If both `resolvePromise` and `rejectPromise` are called,             // or multiple calls to the same argument are made,             // the first call takes precedence, and any further calls are ignored.             if (called) {               return             }             called = true              promiseResolutionProcedure(promise, y, resolve, reject)           },            // `rejectPromise`           // 2.3.3.3.2 If/when `rejectPromise` is called with a reason `r`,           // reject `promise` with `r`           r =&gt; {             // 2.3.3.3.3             if (called) {               return             }             called = true              reject(r)           }         )       } else {         // 2.3.3.4 If `then` is not a function, fulfill `promise` with `x`         resolve(x)       }     } catch (e) {       // 2.3.3.3.3       if (called) {         return       }       called = true        // 2.3.3.2 If retrieving the property `x.then` results in a thrown exception `e`,       // reject `promise` with `e` as the reason.        // 2.3.3.3.4 If calling `then` throws an exception `e`       //   2.3.3.3.4.1 If `resolvePromise` or `rejectPromise` have been called, ignore it       //   2.3.3.3.4.2 Otherwise, reject `promise` with `e` as the reason        reject(e)     }   } } </code></pre> <p><strong>2.3.3.4</strong> 如果 <code>then</code> 不是函数，则执行该 <code>promise</code>，参数为 <code>x</code></p> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码    if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {     try {       let then = x.then        if (typeof then === 'function') {         // 2.3.3.3       } else {         // 2.3.3.4 If `then` is not a function, fulfill `promise` with `x`         resolve(x)       }     } catch (e) {     }   } } </code></pre> <h4 id="234-如果-x-既不是对象也不是函数">2.3.4 如果 <code>x</code> 既不是对象也不是函数</h4> <p>如果 <code>x</code> 既不是对象也不是函数，执行该 <code>promise</code>，参数为 <code>x</code>：</p> <pre><code class="language-javascript">const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...其他代码    if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {      // 2.3.3   } else {     // 2.3.4 If `x` is not an object or function, fulfill `promise` with `x`     resolve(x)   } } </code></pre> <p>至此，我们的自定义 <code>Promise</code> 已经完成。这是源码：promise-aplus-implementing。</p> <h2 id="4-如何测试">4. 如何测试</h2> <p>Promise/A+ 规范提供了一个测试脚本：promises-tests，你可以用它来测试你的实现是否符合规范。</p> <p>在 <code>PromiseImpl.js</code> 里添加以下代码：</p> <pre><code class="language-javascript">// PromiseImpl.js  const STATUS_PENDING = 'pending' const STATUS_FULFILLED = 'fulfilled' const STATUS_REJECTED = 'rejected'  const invokeArrayFns = (fns, arg) =&gt; {   // ...相关代码 }  const promiseResolutionProcedure = (promise, x, resolve, reject) =&gt; {   // ...相关代码 }  class PromiseImpl {   // ...相关代码 }  PromiseImpl.defer = PromiseImpl.deferred = () =&gt; {   const dfd = {}   dfd.promise = new PromiseImpl((resolve, reject) =&gt; {     dfd.resolve = resolve     dfd.reject = reject   })    return dfd }  module.exports = PromiseImpl </code></pre> <p>然后在 <code>package.json</code> 里添加 <code>scripts</code>：</p> <pre><code class="language-json">// package.json  {   "scripts": {     "test": "promises-aplus-tests PromiseImpl.js"   } } </code></pre> <p>然后，运行 <code>npm run test</code>，执行测试脚本，如果你的实现符合 Promise/A+ 规范的话，所有测试用例均会通过。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220505/03cd57a524d3733862668206c46ffe4e.jpg" alt="按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具"></p> <h2 id="5-其他-api-的实现">5. 其他 API 的实现</h2> <p>Promise/A+ 规范只规定了 <code>then()</code> 方法的实现，其他的如 <code>catch()</code>、<code>finally()</code> 等方法并不在规范里。但就实现而言，这些方法可以通过对 <code>then()</code> 方法或其他方式进行二次封装来实现。</p> <p>另外，像是 <code>all()</code>、<code>race()</code> 等这些方法，其参数为一个<strong>可迭代</strong>对象，如 <code>Array</code>、<code>Set</code>、<code>Map</code> 等。那么，什么是<strong>可迭代</strong>对象根据 ES6 中的规范，要成为<strong>可迭代</strong>对象，一个对象必须实现 <code>@@iterator</code> 方法，即该对象必须有一个名为 <code>@@iterator</code> 的属性，通常我们使用常量 Symbol.iterator 来访问该属性。</p> <p>根据以上信息，判断一个参数是否为<strong>可迭代</strong>对象，其实现如下：</p> <pre><code class="language-javascript">const isIterable = value =&gt; !!value &amp;&amp; typeof value[Symbol.iterator] === 'function' </code></pre> <h3 id="promiseresolve">Promise.resolve</h3> <p><code>Promise.resolve(value)</code>，<strong>静态方法</strong>，其参数有以下几种可能：</p> <ul> <li>参数是 <code>Promise</code> 对象</li> <li>参数是 <code>thenable</code> 对象（拥有 <code>then()</code> 方法的对象）</li> <li>参数是原始值或不具有 <code>then()</code> 方法的对象</li> <li>参数为空</li> </ul> <p>因此，其返回值由其参数决定：有可能是一个具体的值，也有可能是一个 <code>Promise</code> 对象：</p> <pre><code class="language-javascript">class PromiseImpl {   static resolve(value) {     // 1. 参数是 Promise 对象     if (value instanceof PromiseImpl) {       return value     }      // 2. 参数是 thenable     if (value !== null &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.then === 'function') {       return new PromiseImpl((resolve, reject) =&gt; {         value.then(           v =&gt; resolve(v),           e =&gt; reject(e)         )       })     }      // 3. 参数是原始值或不具有 `then()` 方法的对象     // 4. 参数为空     return new PromiseImpl((resolve, reject) =&gt; resolve(value))   } } </code></pre> <h3 id="promisereject">Promise.reject</h3> <p><code>Promise.reject(reason)</code>，<strong>静态方法</strong>，参数为 <code>Promise</code> 拒绝执行时的原因，同时返回一个 <code>Promise</code> 对象，状态为 <code>rejected</code>：</p> <pre><code class="language-javascript">class PromiseImpl {    static reject(reason) {     return new PromiseImpl((resolve, reject) =&gt; reject(reason))   } } </code></pre> <h3 id="promiseprototypecatch">Promise.prototype.catch</h3> <p><code>Promise.prototype.catch(onRejected)</code> 其实就是 <code>then(null, onRejected)</code> 的语法糖：</p> <pre><code class="language-javascript">class PromiseImpl {   catch(onRejected) {     return this.then(null, onRejected)   } } </code></pre> <h3 id="promiseprototypefinally">Promise.prototype.finally</h3> <p>顾名思义，不管 <code>Promise</code> 最后的结果是 <code>fulfilled</code> 还是 <code>rejected</code>，<code>finally</code> 里的语句都会执行：</p> <pre><code class="language-javascript">class PromiseImpl {   finally(onFinally) {     return this.then(       value =&gt; PromiseImpl.resolve(onFinally()).then(() =&gt; value),        reason =&gt; PromiseImpl.resolve(onFinally()).then(() =&gt; { throw reason })     )   } } </code></pre> <h3 id="promiseall">Promise.all</h3> <p><code>Promise.all(iterable)</code>，<strong>静态方法</strong>，参数为<strong>可迭代</strong>对象：</p> <ul> <li>只有当 <code>iterable</code> 里所有的 <code>Promise</code> 都成功执行后才会 <code>fulfilled</code>，回调函数的返回值为所有 <code>Promise</code> 的返回值组成的数组，顺序与 <code>iterable</code> 的顺序保持一致。</li> <li>一旦有一个 <code>Promise</code> 拒绝执行，则状态为 <code>rejected</code>，并且将第一个拒绝执行的 <code>Promise</code> 的原因作为回调函数的返回值。</li> <li>该方法会返回一个 <code>Promise</code>。</li> </ul> <pre><code class="language-javascript">class PromiseImpl {   static all(iterable) {     if (!isIterable(iterable)) {       return new TypeError(`TypeError: ${typeof iterable} is not iterable (cannot read property Symbol(Symbol.iterator))`)     }      return new PromiseImpl((resolve, reject) =&gt; {       // `fulfilled` 的 Promise 数量       let fulfilledCount = 0       // 收集 Promise `fulfilled` 时的值       const res = []          for (let i = 0; i &lt; iterable.length; i++) {         const iterator = iterable[i]         iterator.then(           value =&gt; {             res[i] = value             fulfilledCount++             if (fulfilledCount === iterable.length) {               resolve(res)             }           },           reason =&gt; reject(reason)         )       }     })   } } </code></pre> <p>测试一下：</p> <pre><code class="language-javascript">const promise1 = Promise.resolve(42) const promise2 = new PromiseImpl((resolve, reject) =&gt; setTimeout(() =&gt; resolve('value2'), 1000))  PromiseImpl.all([   promise1,   promise2 ]).then(values =&gt; console.log('values:', values)) </code></pre> <p>结果：</p> <pre><code class="language-javascript">values: [42, 'value2'] </code></pre> <p>好像挺完美的，但是事实果真如此吗？仔细看看我们的代码，假如 <code>iterable</code> 是一个空的数组呢？假如 <code>iterable</code> 里有不是 <code>Promise</code> 的呢？就像这样：</p> <pre><code class="language-javascript">PromiseImpl.all([]) PromiseImpl.all([promise1, promise2, 'value3']) </code></pre> <p>这种情况下执行前面的代码，是得不到任何结果的。因此，代码还要再改进一下：</p> <pre><code class="language-javascript">class PromiseImpl {   static all(iterable) {     if (!isIterable(iterable)) {       return new TypeError(`TypeError: ${typeof iterable} is not iterable (cannot read property Symbol(Symbol.iterator))`)     }      return new PromiseImpl((resolve, reject) =&gt; {       // `fulfilled` 的 Promise 数量       let fulfilledCount = 0       // 收集 Promise `fulfilled` 时的值       const res = []              // - 填充 `res` 的值       // - 增加 `fulfilledCount`       // - 判断所有 `Promise` 是否已经全部成功执行       const processRes = (index, value) =&gt; {         res[index] = value         fulfilledCount++         if (fulfilledCount === iterable.length) {           resolve(res)         }       }        if (iterable.length === 0) {         resolve(res)       } else {         for (let i = 0; i &lt; iterable.length; i++) {           const iterator = iterable[i]                      if (iterator &amp;&amp; typeof iterator.then === 'function') {             iterator.then(               value =&gt; processRes(i, value),               reason =&gt; reject(reason)             )           } else {             processRes(i, iterator)           }         }       }     })   } } </code></pre> <p>现在再来测试一下：</p> <pre><code class="language-javascript">const promise1 = PromiseImpl.resolve(42) const promise2 = 3 const promise3 = new PromiseImpl((resolve, reject) =&gt; setTimeout(() =&gt; resolve('value3'), 1000))  PromiseImpl.all([   promise1,   promise2,   promise3,   'a' ]).then(values =&gt; console.log('values:', values)) // 结果：values: [42, 3, 'value3', 'a']  PromiseImpl.all([]).then(values =&gt; console.log('values:', values)) // 结果：values: [] </code></pre> <h3 id="promiseallsettled">Promise.allSettled</h3> <p><code>Promise.allSettled(iterable)</code>，<strong>静态方法</strong>，参数为<strong>可迭代</strong>对象：</p> <ul> <li>当 <code>iterable</code> 里所有的 <code>Promise</code> 都成功执行或拒绝执行后才完成，返回值是一个对象数组。</li> <li>如果有嵌套 <code>Promise</code>，需要等待该 <code>Promise</code> 完成。</li> <li>返回一个新的 <code>Promise</code> 对象。</li> </ul> <p>对于 <code>allSettled</code>，我们可以在 <code>all</code> 的基础上进行封装：</p> <pre><code class="language-javascript">class PromiseImpl {   static allSettled(iterable) {     if (!isIterable(iterable)) {       return new TypeError(`TypeError: ${typeof iterable} is not iterable (cannot read property Symbol(Symbol.iterator))`)     }      const promises = iterable.map(iterator =&gt; PromiseImpl.resolve(iterator).then(       value =&gt; ({ status: STATUS_FULFILLED, value }),       reason =&gt; ({ status: STATUS_REJECTED, reason })     ))      return PromiseImpl.all(promises)   } } </code></pre> <p>测试结果：</p> <pre><code class="language-javascript">class PromiseImpl {   static allSettled(iterable) {     if (!isIterable(iterable)) {       return new TypeError(`TypeError: ${typeof iterable} is not iterable (cannot read property Symbol(Symbol.iterator))`)     }      const promises = []     for (const iterator of iterable) {       promises.push(         PromiseImpl.resolve(iterator).then(           value =&gt; ({ status: STATUS_FULFILLED, value }),           reason =&gt; ({ status: STATUS_REJECTED, reason })         )       )     }      return PromiseImpl.all(promises)   } } </code></pre> <p>测试结果：</p> <pre><code class="language-javascript">PromiseImpl.allSettled([   PromiseImpl.resolve(42),   PromiseImpl.reject('Oops!'),   PromiseImpl.resolve(PromiseImpl.resolve(4242)),   'a' ]).then(values =&gt; console.log(values)) // 结果： // [ //   { status: 'fulfilled', value: 42 }, //   { status: 'rejected', reason: 'Oops!' }, //   { status: 'fulfilled', value: 4242 }, //   { status: 'fulfilled', value: 'a' } // ] </code></pre> <h3 id="promiserace">Promise.race</h3> <p><code>Promise.race(iterable)</code>，<strong>静态方法</strong>，参数为<strong>可迭代</strong>对象：</p> <ul> <li>当 <code>iterable</code> 里的任一 <code>Promise</code> 成功执行或拒绝执行时，使用该 <code>Promise</code> 成功返回的值或拒绝执行的原因</li> <li>如果 <code>iterable</code> 为空，则处于 <code>pending</code> 状态</li> <li>返回一个新的 <code>Promise</code> 对象</li> </ul> <p>例如：</p> <pre><code class="language-javascript">Promise.race([   Promise.resolve(42),   Promise.reject('Oops!'),   'a' ]).then(values =&gt; console.log(values))   .catch(reason =&gt; console.log(reason)) // 结果：42  Promise.race([   Promise.reject('Oops!'),   Promise.resolve(42),   'a' ]).then(values =&gt; console.log(values))   .catch(reason =&gt; console.log(reason)) // 结果：Oops! </code></pre> <p>实现如下：</p> <pre><code class="language-javascript">class PromiseImpl {   static race(iterable) {     if (!isIterable(iterable)) {       return new TypeError(`TypeError: ${typeof iterable} is not iterable (cannot read property Symbol(Symbol.iterator))`)     }      return new PromiseImpl((resolve, reject) =&gt; {       if (iterable.length === 0) {         return       } else {         for (let i = 0; i &lt; iterable.length; i++) {           const iterator = iterable[i]                      if (iterator &amp;&amp; typeof iterator.then === 'function') {             iterator.then(               value =&gt; resolve(value),               reason =&gt; reject(reason)             )             return           } else {             resolve(iterator)             return           }         }       }     })   } } </code></pre> <p><strong>这里要注意一点：别忘了使用 <code>return</code> 来结束 <code>for</code> 循环</strong>。</p> <p>测试结果：</p> <pre><code class="language-javascript">PromiseImpl.race([   PromiseImpl.resolve(42),   PromiseImpl.reject('Oops!'),   'a' ]).then(values =&gt; console.log(values))   .catch(reason =&gt; console.log(reason)) // 结果：42  PromiseImpl.race([   PromiseImpl.reject('Oops!'),   PromiseImpl.resolve(42),   'a' ]).then(values =&gt; console.log(values))   .catch(reason =&gt; console.log(reason)) // 结果：'Oops!'  PromiseImpl.race([   'a',   PromiseImpl.reject('Oops!'),   PromiseImpl.resolve(42) ]).then(values =&gt; console.log(values))   .catch(reason =&gt; console.log(reason)) // 结果：'a' </code></pre> <h2 id="6-共同探讨">6. 共同探讨</h2> <ol> <li>在 <strong>2.3.3.1 把 <code>x.then</code> 赋值给 <code>then</code></strong> 中，什么情况下 <code>x.then</code> 的指向会被改变？</li> <li>在 <strong>2.3.3.3 如果 <code>then</code> 是函数</strong> 中，除了使用 <code>call()</code> 之外，还有什么其他方式实现吗？</li> </ol> <h2 id="7-总结">7. 总结</h2> <p>实现 <code>Promise</code>，基本分为三个步骤：</p> <ol> <li>定义 <code>Promise</code> 的状态</li> <li>实现 <code>then</code> 方法</li> <li>实现 <code>Promise</code> 解决过程</li> </ol> <h2 id="8-写在最后">8. 写在最后</h2> <p>以前，我在意能不能自己实现一个 <code>Promise</code>，到处找文章，这块代码 <code>Ctrl+C</code>，那块代码 <code>Ctrl+V</code>。现在，我看重的是实现的过程，在这个过程中，你不仅会对 <code>Promise</code> 更加熟悉，还可以学习如何将规范一步步转为实际代码。<strong>做对的事，远比把事情做对重要</strong>。</p> <p>如果你觉得这篇文章对你有帮助，还请：<strong>点赞、收藏、关注</strong>；如果你有疑问，请在评论区写出来，我们一起探讨。同时也欢迎关注我的公众号：<strong>前端笔记</strong>。</p> <h2 id="参考资料">参考资料</h2> <ul> <li>Promises/A+</li> <li>Promise A+ 规范</li> <li>使用 Promise - MDN</li> <li>Promise - MDN</li> </ul> 			                </div>
                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-111569.htm"># kubernetes调度之nodeName与NodeSelector</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-111573.htm" title="按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具">按照 Promise/A+ 规范逐行注释并实现 Promise_在线工具</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-12-clash-verge-rev-node-share.htm" title="「4月12日」最高速度20.4M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接">「4月12日」最高速度20.4M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-20-free-node-subscribe-links.htm" title="「4月20日」最高速度18.9M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接">「4月20日」最高速度18.9M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-88378.htm" title="Sentinel基础应用详解">Sentinel基础应用详解</a></li>
                        <li class="py-2"><a href="/news/article-93546.htm" title="站在巨人的肩膀上重新审视C# Span&lt;T&gt;数据结构_在线工具">站在巨人的肩膀上重新审视C# Span&lt;T&gt;数据结构_在线工具</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-5-7-node-share-links.htm" title="「5月7日」最高速度19.6M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接">「5月7日」最高速度19.6M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-95832.htm" title="猫三联一共几针,多少钱2020（猫三联一共几针,多少钱大同）">猫三联一共几针,多少钱2020（猫三联一共几针,多少钱大同）</a></li>
                        <li class="py-2"><a href="/news/article-93542.htm" title="使用etcd选举sdk实践master/slave故障转移_在线工具">使用etcd选举sdk实践master/slave故障转移_在线工具</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-29-node-share-links.htm" title="「4月29日」最高速度18.6M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接">「4月29日」最高速度18.6M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-13-clash-verge-rev-node-share.htm" title="「4月13日」最高速度20.2M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接">「4月13日」最高速度20.2M/S，2025年FreeClashVerge每天更新免费机场订阅节点链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">17</span> <a href="/date/2025-05/" title="2025-05 归档">2025-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">89</span> <a href="/date/2025-04/" title="2025-04 归档">2025-04</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
    <!--================ End About Us Area =================-->
        <!--================Footer Area =================-->
    <footer class="footer_area">
        <div class="container">
            <div class="row footer_bottom justify-content-center">
                <p class="col-lg-8 col-sm-12 footer-text">
                                        <p>
                                                <a href="/">首页</a> |
                                                <a href="/free-nodes/">免费节点</a> |
                                                <a href="/paid-subscribe/">推荐机场</a> |
                                                <a href="/client.htm">客户端</a> |
                                                <a href="/news/">新闻资讯</a> |
                                                <a href="/about-us.htm">关于我们</a> |
                        <a href="/disclaimer.htm">免责申明</a> |
                        <a href="/privacy.htm">隐私申明</a> |
                        <a href="/sitemap.xml">网站地图</a>
                    </p>
                    FreeClashVerge免费节点官网 版权所有 Powered by WordPress
                </p>
            </div>
        </div>
    </footer>
    <!--================End Footer Area =================-->
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="/assets/website/js/frontend/freeclashverge/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/popper.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/bootstrap.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/stellar.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/jquery.magnific-popup.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/nice-select/js/jquery.nice-select.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/isotope/imagesloaded.pkgd.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/isotope/isotope-min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/owl-carousel/owl.carousel.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/jquery.ajaxchimp.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/mail-script.js"></script>
    <!--gmaps Js-->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCjCGmQ0Uq4exrzdcL6rvxywDDOvfAu6eE"></script>
    <script src="/assets/website/js/frontend/freeclashverge/gmaps.min.js"></script>
    <script src="/assets/website/js/frontend/freeclashverge/theme.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script>
    <script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>